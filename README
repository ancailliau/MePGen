MePGen is a memorable password generator.


Memorable password
------------------

A memorable password is
	- composed of (upper- and lowercase) consonants and vowels, punctuation and numbers;
	- composed of several words separated by punctuation and numbers.
	
A word
	- is composed of consonants and vowels;
	- starts with an uppercase letter, followed by lowercase ones, or in lowercase, or in uppercase;
	- is composed of syllables, such that for two subsequent syllables, it is not the case that the first one ends with a vowel and the second one starts with a vowel.
	
A syllable is
	- or one or two consonants followed by a vowel;
	- or a consonant, a vowel and a consonant;
	- or a vowel followed by one or two consonants.
i.e., (C)CV, CVC, VC(C).


Probabilities
-------------

Let's have all words of a given length. We want to choose one of them uniformly. 

We want to design an algorithm that generate a word of a given length with the same probability.

If we generate a word character by character, we can see the algorithm as follows: when choosing the next character, the possible range of characters is determined by all the preceeding characters. So choose the next character uniformly in this range.

Does the probability to generate a word of a given length using the one-by-one technique above the same as the probability of choosing this word in the long list of possible words of the given length?

Example:
	aa	  1/3 * 1 = 1/3      [a,b,c] -a> [a]
	ba    1/3 * 1/2 = 1/6            -b> [a,b]
	bb    1/3 * 1/2 = 1/6            -c> [a,b,c]
	ca    1/3 * 1/3 = 1/9                  
	cb    1/3 * 1/3 = 1/9                   
	cc    1/3 * 1/3 = 1/9
	
	=> It is not the correct way!
	
A possible solution would be to precompute, for each range, the probability distribution.

	[	a,		b,		c	]	-a> [	a	]
	    1/6		1/3		1/2				1
	 							-b> [	a,		b	]
										1/2		1/2
								-c> [	a,		b,		c	]
										1/3		1/3		1/3
														
	aa		1/6 * 1   =	1/6
	ba		1/3 * 1/2 = 1/6
	bb		1/3 * 1/2 = 1/6
	ca		1/2 * 1/3 = 1/6
	cb		1/2 * 1/3 = 1/6
	cc		1/2 * 1/3 = 1/6

								
Grammar
-------

A memorable password follows this grammar (using some regex notations...):

PASS := WORD ((punc | numb)+ WORD)*
WORD := SYLL+
SYLL := cons? cons vowe | cons vowe cons | vowe cons cons?


How to generate a memorable password?

When generating any password (not a memorable one), we choose one character at a time, but the next character range is independant from the already chosen one. In our case, a possibility is to change the possible range in terms of the already chosen characters.

It seems difficult to generate a word from a grammar, such that probabilities are fine. It seems easier with regex!


Regex
-----

A memorable password follows this regex (in fact, its the grammar given above...):

PASS := WORD (SEPA WORD)*
SEPA := punc? digi+ punc? | punc? punc 
WORD := SYLL+
SYLL := cons? cons vowe | cons vowe cons | vowe cons cons?

It seems easier to generate a word from a regex. Indeed, when we have the automaton of the regex, the possible following characters depends on the successors of the current state.

To generate the automaton recognizing all the words of a given length
	- generate the automaton of the regex recognizing the words
	- generate the automaton recognizing any word of a given length
	- compute the intersection of the two automata
	
	
Proposed solution
-----------------

Let the regex of memorable passwords be

PASS := SEPA? WORD (SEPA WORD)* SEPA?
SEPA := punc? digi+ punc? | punc? punc 
WORD := SYLL+
SYLL := cons? cons vowe | cons vowe cons | vowe cons cons?

1. Build the automaton from this regex.
2. Minimize and determinize it.
3. Unroll it to the chosen length, giving a tree automaton (an automaton having the shape of a tree) recognizing only memorable passwords of the given length (only leaves are accepting).
4. Compute the number of possible words for each subtree.
5. Compute a random password by performing a top-down traversal of the tree, using probabilities based on number of words for subtrees.

Notes
	- The resulting tree can be minimized Ã  la BDD.
	- From the tree, we have to remove every non-accepting leaf (and transitions to them) to keep only accepting paths, allowing to compute correct number of words and random word.
	
	- Removing lambda transitions is necessary since it is easier to count words of a given length without lambdas. It becomes more tricky (maybe impossible!) when there are lambda transitions.
	- There is no need to minimize the automaton when it is determinized, we just need no lambda transitions. When it is determinized, there is only one path for a single word, so the word will be counted only once.
	- We just need to build the automaton, remove lambda transitions, determinize it and then we can build the tree, count the words and generate words.
	
	
Improvement
-----------

Even with small regex and ranges, it takes a long time and memory to compute passwords of length 16.
ex: ([a] . [cbd]*)*
The problem seems to lie in automaton_to_wordtree, that takes a lot of time in this case.
A way to improve it is maybe to construct a BDD-like DAG to avoid explosion in memory (and maybe in time).
This improvement seems to really speed up the process.
There is still some computing time in removing empty subtrees. Is this step really needed? An empty subtree won't act in the computing of a word since the probability to take it is 0!


New idea
--------

Find probably usefull letter associations by analyzing a given text. From the text, count for each character the set of possible next ones, and define probabilities of following characters. Then, by fixing a bound on these probabilities, fix the next possible characters.

Is this solution interesting? If 's' can follow 't' and 'h' can follow 's' and 'r' can follow 'h', we can construct 'tshr', while we don't want to. Maybe by using a sufficiently high bound, we can avoid these?

Furthermore, does this system can still provide sufficiently large set of words?