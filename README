MePGen is a memorable password generator.


Memorable password
------------------

A memorable password is
	- composed of (upper- and lowercase) consonants and vowels, punctuation and numbers;
	- composed of several words separated by punctuation and numbers.
	
A word
	- is composed of consonants and vowels;
	- starts with an uppercase letter, followed by lowercase ones, or in lowercase, or in uppercase;
	- is composed of syllables, such that for two subsequent syllables, it is not the case that the first one ends with a vowel and the second one starts with a vowel.
	
A syllable is
	- or one or two consonants followed by a vowel;
	- or a consonant, a vowel and a consonant;
	- or a vowel followed by one or two consonants.
i.e., (C)CV, CVC, VC(C).


Probabilities
-------------

Let's have all words of a given length. We want to choose one of them uniformly. 

We want to design an algorithm that generate a word of a given length with the same probability.

If we generate a word character by character, we can see the algorithm as follows: when choosing the next character, the possible range of characters is determined by all the preceeding characters. So choose the next character uniformly in this range.

Does the probability to generate a word of a given length using the one-by-one technique above the same as the probability of choosing this word in the long list of possible words of the given length?

Example:
	aa	  1/3 * 1 = 1/3      [a,b,c] -a> [a]
	ba    1/3 * 1/2 = 1/6            -b> [a,b]
	bb    1/3 * 1/2 = 1/6            -c> [a,b,c]
	ca    1/3 * 1/3 = 1/9                  
	cb    1/3 * 1/3 = 1/9                   
	cc    1/3 * 1/3 = 1/9
	
	=> It is not the correct way!
	
A possible solution would be to precompute, for each range, the probability distribution.

	[	a,		b,		c	]	-a> [	a	]
	    1/6		1/3		1/2				1
	 							-b> [	a,		b	]
										1/2		1/2
								-c> [	a,		b,		c	]
										1/3		1/3		1/3
														
	aa		1/6 * 1   =	1/6
	ba		1/3 * 1/2 = 1/6
	bb		1/3 * 1/2 = 1/6
	ca		1/2 * 1/3 = 1/6
	cb		1/2 * 1/3 = 1/6
	cc		1/2 * 1/3 = 1/6

								
Grammar
-------

A memorable password follows this grammar (using some regex notations...):

PASS := WORD ((punc | numb)+ WORD)*
WORD := SYLL+
SYLL := cons? cons vowe | cons vowe cons | vowe cons cons?


How to generate a memorable password?

When generating any password (not a memorable one), we choose one character at a time, but the next character range is independant from the already chosen one. In our case, a possibility is to change the possible range in terms of the already chosen characters.

It seems difficult to generate a word from a grammar, such that probabilities are fine. It seems easier with regex!


Regex
-----

A memorable password follows this regex (in fact, its the grammar given above...):

PASS := WORD (SEPA WORD)*
SEPA := punc? digi+ punc? | punc? punc 
WORD := SYLL+
SYLL := cons? cons vowe | cons vowe cons | vowe cons cons?

It seems easier to generate a word from a regex. Indeed, when we have the automaton of the regex, the possible following characters depends on the successors of the current state.

To generate the automaton recognizing all the words of a given length
	- generate the automaton of the regex recognizing the words
	- generate the automaton recognizing any word of a given length
	- compute the intersection of the two automata
	
	
Proposed solution
-----------------

Let the regex of memorable passwords be

PASS := WORD (SEPA WORD)*
SEPA := punc? digi+ punc? | punc? punc 
WORD := SYLL+
SYLL := cons? cons vowe | cons vowe cons | vowe cons cons?

1. Build the automaton from this regex.
2. Minimize and determinize it.
3. Unroll it to the chosen length, giving a tree automaton (an automaton having the shape of a tree) recognizing only memorable passwords of the given length (only leaves are accepting).
4. Compute the number of possible words for each subtree.
5. Compute a random password by performing a top-down traversal of the tree, using probabilities based on number of words for subtrees.

Notes
	- the resulting tree can be minimized Ã  la BDD.
	- from the tree, we have to remove every non-accepting leaf (and transitions to them) to keep only accepting paths, allowing to compute correct number of words and random word.